---
layout: single
title: "개발자 기술 면접 질문 정리-01"
categories: STUDY4242
classes: wide
---

# 개발자 기술 면접 1주차 스터디에 대한 정리

## 01. 클래스, 객체, 생성자에 대해 설명해주세요.

### 1. 클래스

**정의**
객체를 정의하는 틀 또는 설계도 <br>
객체의 상태를 나타내는 필드(field)와 객체의 동작을 나타내는 메서드(method)로 구성되어있다. <br>
즉, 필드란 클래스에 포함된 변수(variable)를 의미하며 메서드는 특정 작업을 수행하기 위한 명령문의 집합인 셈이다. <br>

**구성 요소**
1. 클래스 선언
  - 형식 : `public class ClassName {...}`
    - `public` : 접근 제어자로 다른 패키지나 클래스에서도 위 클래스를 접근할 수 있음을 의미
    - `class` : 자바에서 클래스를 정의할 때 사용하는 키워드
    - `ClassName` : 클래스의 이름

2. 속성(fields)
  - 형식 : `타입 변수명;`
  - 클래스의 상태를 표현하며 객체가 갖는 정보 저장

3. 메서드
  - 형식 : `타입 메서드명() {...}`
  - 객체가 호출할 수 있는 동작 정의

**예시**
```
public class Student {
    // 속성 (fields)
    String major;
    int grade;
    boolean attending;

    // 메서드 (method)
    void goToSchool() {
        System.out.println("등교 중입니다.");
    }
}
```

**클래스를 사용하는 이유**
- **코드의 재사용성**
 : 유사한 기능을 하는 코드를 여러 곳에서 쉽게 재사용할 수 있다. 이는 코드의 가독성과 유지보수성을 높인다.
- **유지보수성의 향상**
 : 관련 있는 코드를 논리적으로 그룹화하여 구조적으로 정리할 수 있다. 이는 코드의 가독성과 유지보수성을 향상시킨다.
- **코드의 안정성**
 : 각 클래스는 자체적으로 캡슐화되어 있으며, 다른 클래스와 독립적으로 작동한다. 이를 통해 클래스는 자신의 메서드와 속성만을 외부에서 접근할 수 있도록 제한할 수 있다.

### 2. 객체

**정의**
클래스의 인스턴스를 기반으로 생성된 실체 <br>
클래스에서 정의한 상태와 동작을 실제로 구현하며, 클래스의 설계도를 바탕으로 메모리에 할당된 구체적인 데이터를 포함한다. <br>
객체는 상태를 표현하는 필드와 동작을 수행하는 메서드로 구성됩니다. <br>

**구성 요소**
1. 객체의 상태 (state)
  - 클래스에서 정의한 필드(속성)의 값으로 객체가 현재 어떤 값을 가지고 있는지 나타낸다. 즉, 객체의 동작과 관련된 정보이다.

2. 객체의 정보 (information)
  - 객체의 정보는 객체의 상태와 그 상태가 의미하는 바를 포함한다. 즉, 객체가 갖는 데이터와 해당 데이터가 객체의 역할을 어떻게 설명하는지 포함한다.

**예시**
```
public class Student {
    String major;
    int grade;
    boolean attending;

    void goToSchool() {
        System.out.println("등교 중입니다.");
    }
}

// 객체 생성 및 사용 예시
public class Main {
    public static void main(String[] args) {
        // Student 클래스의 객체 생성
        Student student = new Student();

        // 객체의 상태 설정
        student.major = "Computer Science";
        student.grade = 2;
        student.attending = true;

        // 객체의 메서드 호출
        student.goToSchool();
    }
}
```

**객체를 사용하는 이유**
- **구체화**
 : 클래스는 설계도일 뿐, 객체는 이 설계도를 바탕으로 실제로 메모리에 할당된 실체이다. 객체를 사용하여 클래스에서 정의한 상태와 동작을 실질적으로 구현한다.

 - **상태와 행동**
 : 객체는 상태를 갖고, 이 상태를 바탕으로 행동(메서드 호출)을 수행할 수 있다. 객체의 상태는 필드(속성)로 저장되고, 행동은 메서드로 정의된다.

- **실체화된 데이터**
 : 객체는 클래스의 설계도를 바탕으로 실제 데이터를 메모리에 저장하며, 이를 통해 프로그램이 동작하는 실제 데이터를 관리한다.

### 3. 생성자

**정의**
객체가 생성될 때 호출되는 특수한 메서드 <br> 
생성자의 주요 목적은 객체의 초기 상태를 설정하는 것이며, 객체가 생성될 때 필드의 초기값을 설정하거나 필요한 초기 작업을 수행한다. <br>
생성자는 클래스와 같은 이름을 가지며, 반환 타입이 없다. <br>

**구성 요소**
1. 생성자 선언
  - 형식 : `ClassName() {...}`
  - 생성자는 클래스의 이름과 동일해야 하며, 반환 타입이 없다.\
  - 생성자의 본문에는 객체의 초기화 작업을 수행하는 코드가 포함된다.

2. 생성자의 역할
  - **초기화** : 객체를 생성할 때 필드에 초기값을 설정하여 객체의 상태를 초기화한다.
  - **설정** : 객체가 생성될 때 필요한 설정 작업을 수행한다.

3. 기본 생성자와 매개변수 생성자
  - **기본 생성자** : 매개변수가 없는 생성자로, 자바에서 기본적으로 제공되며, 객체를 생성할 때 필드를 기본값으로 초기화한다.
  - **매개변수 생성자** : 생성자에 매개변수를 전달하여 객체의 상태를 초기화한다. 매개변수 생성자를 사용하면 객체 생성 시 초기 값을 직접 설정할 수 있다.

**예시**
```
public class Student {
    String major;
    int grade;
    boolean attending;

    // 기본 생성자
    public Student() {
        this.major = "Undeclared";
        this.grade = 1;
        this.attending = false;
    }

    // 매개변수 생성자
    public Student(String major, int grade, boolean attending) {
        this.major = major;
        this.grade = grade;
        this.attending = attending;
    }
}

// 객체 생성 및 사용 예
public class Main {
    public static void main(String[] args) {
        // 기본 생성자를 사용하여 객체 생성
        Student defaultStudent = new Student();
        System.out.println("Default Student: " + defaultStudent.major + ", " + defaultStudent.grade + ", " + defaultStudent.attending);

        // 매개변수 생성자를 사용하여 객체 생성
        Student specificStudent = new Student("Computer Science", 2, true);
        System.out.println("Specific Student: " + specificStudent.major + ", " + specificStudent.grade + ", " + specificStudent.attending);
    }
}
```

**생성자를 사용하는 이유**
- **객체 초기화** : 객체를 생성할 때 필요한 초기값을 설정하여 객체의 상태를 올바르게 초기화할 수 있다.
- **유연성** : 다양한 초기값을 설정할 수 있도록 매개변수 생성자를 제공하여 객체 생성 시 필요한 데이터를 직접 전달할 수 있다.
- **캡슐화** : 객체가 생성될 때 필드의 유효한 값을 설정함으로써 데이터의 일관성을 유지하고, 객체의 상태를 안정적으로 유지할 수 있다.

## 02. VO, BO, DAO, DTO에 대해 설명해주세요.

### 1. VO (Value Object)

**정의**
실제 데이터만을 저장하기 위한 객체 <br>
VO는 특정 값을 가지고 있으며, 불변성(read-only)의 속성을 가지며 getter만 가능하다. <br> 
주로 데이터의 묶음을 표현하고, 객체 간의 데이터를 전달할 때 사용된다. <br>

> **객체의 불변성** : 객체의 정보가 변경되지 않음 <br>
> 즉, 수정할 수 없기 때문에 setter를 사용할 수 없다.

따라서 VO는 데이터가 불변이어야 하고, 단순히 저장된 값을 불러와야 하는 경우 사용된다. <br>
고정된 값은 VO로 저장 후 Getter를 통해 호출한다.

**예시**
```
public class PersonVO {
    private final String name;
    private final int age;

    public PersonVO(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public int getAge() {
        return age;
    }
}
```

### 2. BO (Business Object)

**정의**
여러 DAO를 활용해 비즈니스 로직을 처리하는 객체 (Service에 해당) <br>
비즈니스 규칙과 연산을 캡슐화하여 비즈니스 프로세스를 모델링한다. <br>
비즈니스 로직을 담당하며, 데이터 처리와 관련된 주요 기능을 수행한다. <br>

**구성 요소**
1. 속성 (fields)
  - 비즈니스 로직과 관련된 데이터를 저장한다.
  - 비즈니스 규칙과 관련된 데이터를 나타내며, 상태를 유지한다.

2. 메서드 (methods)
  - 비즈니스 로직을 수행하는 메서드가 포함된다.
  - 비즈니스 로직을 캡슐화하여 데이터 처리와 연산을 수행한다.

**예시**
```
public class AccountBO {
    private double balance;

    public AccountBO(double initialBalance) {
        this.balance = initialBalance;
    }

    public void deposit(double amount) {
        if (amount > 0) {
            balance += amount;
        }
    }

    public void withdraw(double amount) {
        if (amount > 0 && balance >= amount) {
            balance -= amount;
        }
    }

    public double getBalance() {
        return balance;
    }
}
```

**BO를 사용하는 이유**
-   **비즈니스 로직 캡슐화** : 비즈니스 규칙과 로직을 객체에 캡슐화하여 코드의 재사용성과 유지보수성을 높인다.
-   **비즈니스 프로세스 모델링** : 비즈니스 작업을 객체로 모델링하여 복잡한 프로세스를 구조화한다.

### 3. DAO (Data Access Object)

**정의**
DB나 다른 데이터 소스와의 연결을 관리하고, 데이터의 저장 및 검색을 담당하는 객체 <br>
DAO는 데이터 액세스 로직을 캡슐화하여 데이터베이스 작업을 효율적으로 수행한다.

**예시**
```
public class StudentDAO {
    private Connection connection;

    public StudentDAO(Connection connection) {
        this.connection = connection;
    }

    public void addStudent(Student student) throws SQLException {
        String sql = "INSERT INTO students (major, grade, attending) VALUES (?, ?, ?)";
        try (PreparedStatement stmt = connection.prepareStatement(sql)) {
            stmt.setString(1, student.getMajor());
            stmt.setInt(2, student.getGrade());
            stmt.setBoolean(3, student.isAttending());
            stmt.executeUpdate();
        }
    }

    public Student getStudent(int id) throws SQLException {
        String sql = "SELECT * FROM students WHERE id = ?";
        try (PreparedStatement stmt = connection.prepareStatement(sql)) {
            stmt.setInt(1, id);
            ResultSet rs = stmt.executeQuery();
            if (rs.next()) {
                return new Student(rs.getString("major"), rs.getInt("grade"), rs.getBoolean("attending"));
            }
        }
        return null;
    }
}
```

**DAO를 사용하는 이유**
-   **데이터 액세스 분리** : 데이터베이스와의 상호작용을 비즈니스 로직과 분리하여 코드의 유지보수성과 테스트 용이성을 향상시킨다.
-   **CRUD 작업 처리** : 데이터베이스에 대한 Create, Read, Update, Delete 작업을 효율적으로 관리할 수 있다.

### 4. DTO (Data Transfer Object)

**정의**
데이터 전송을 목적으로 사용하는 객체 <br>
DTO는 여러 데이터를 묶어 전송하거나 반환하는 데 사용되며, 주로 계층 간의 데이터 교환을 간소화한다. <br>

**예시**
```
public class StudentDTO {
    private String major;
    private int grade;
    private boolean attending;

    public StudentDTO(String major, int grade, boolean attending) {
        this.major = major;
        this.grade = grade;
        this.attending = attending;
    }

    public String getMajor() {
        return major;
    }

    public void setMajor(String major) {
        this.major = major;
    }

    public int getGrade() {
        return grade;
    }

    public void setGrade(int grade) {
        this.grade = grade;
    }

    public boolean isAttending() {
        return attending;
    }

    public void setAttending(boolean attending) {
        this.attending = attending;
    }
}
```

**DTO를 사용하는 이유**
-   **데이터 전송 간소화**: 여러 데이터를 하나의 객체로 묶어 전송하거나 반환하여 코드의 복잡성을 줄입니다.
-   **계층 간 데이터 교환**: 프레젠테이션 계층과 비즈니스 로직 계층, 데이터 접근 계층 간의 데이터 전송을 간소화합니다.

**DTO와 VO의 차이점** <br>
DTO는 데이터의 전송만을 위한 객체이고, VO는 특정한 비즈니스 로직을 가질 수 있다. <br>
DTO는 데이터 전달만을 목적으로 하고, VO는 객체 자체를 어떠한 값(Value)으로서 사용하기 때문이다. <br>
따라서 외부 시스템과 데이터 통신을 할 경우 DTO를 사용하고, DB에서 가져오는 Data는 VO로 정의한 후 사용한다. <br>
<br>
DTO는 목적 자체가 데이터의 전달이기 때문에 읽고 쓰는 것이 모두 가능한, 가변성을 가진다. <br>
VO는 불변성 및 read-only의 속성을 갖는다. <br>
<br>
또한 VO는 equals()와 hashCode()를 재정의(Override)해서 각 객체의 동일성을 판별할 수 있다.<br>
DTO a = new DTO(1);  <br>
DTO b = new DTO(1);  <br>
라고 했을때 a != b 이다. <br>
`a`와 `b`는 서로 다른 메모리 위치에 저장된 객체이기 때문에 참조가 서로 다르기 때문이다. <br>
VO a = new VO(1);  <br>
VO b = new VO(1);  <br>
라고 했을때 a==b 이다.  <br>
객체의 상태(속성 값)를 비교했기 때문에 같은 값을 가지는 두 VO 객체는 동일한 것으로 판단되기 때문이다. <br>

>`equals()` <br>
> 두 객체의 논리적 동등성을 비교한다. <br>
> 즉, 두 객체가 내용적으로 같은지 여부를 판단한다.

>`hashCode()`
> 객체의 해시 코드를 반환한다. <br>
> 해시 코드는 객체를 해시 기반 컬렉션(예: `HashSet`, `HashMap`)에서 관리하는 데 사용된다.
